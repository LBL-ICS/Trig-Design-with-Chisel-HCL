/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the Floating-Point Design Generator.
 *
 * Author: Xiaokun Yang and Maria Vega, University of Houston Clear Lake 
 * Date: June 2022
 *
 * For more information, see the project website at:
 * https://sceweb.sce.uhcl.edu/xiaokun/OpenIC/
 *
//   Latency: 1 cycle per addition
//   Precision: Single bit
//   Resources required: 16 adders (32 x 32 bit)
*/


module tb_cos();
parameter TEST_SIZE = 10;
`ifdef COS_N32_PD32_BW32
parameter LATENCY = 67; //34+32+1
`elsif COS_N32_PD16_BW32
parameter LATENCY = 51; //? 34+16+1
`elsif COS_N16_PD8_BW16
parameter LATENCY = 31; //? 34+8+1
`elsif COS_N32_PD4_BW32
parameter LATENCY = 40; // 34+4+2
`elsif COS_N32_PD1_BW32
parameter LATENCY = 37; //34+1+2
`endif

parameter ERROR_TOLERANCE = 10;
localparam real PI = 3.141592653589793;
reg [15:0]  output_cos[TEST_SIZE-1:0]; 
reg [15:0]  input_theta[TEST_SIZE-1:0];

`include "tb_func.sv"

initial begin
   $readmemh("../golden/rtl-theta-input.txt",input_theta);
   $readmemh("../golden/rtl-cos-output.txt",output_cos);
end


reg         io_ready;
reg         clock;
reg         reset;
reg  [15:0] io_in;
wire [15:0] io_out;
wire        io_valid ;


 always #5 clock = ~clock;

Cos u_Cos(
  .clock (clock ),
  .reset (reset ),
  .io_ready (io_ready ),
  .io_in (io_in ),
  .io_valid (io_valid ),
  .io_out(io_out)
);
  
integer i; 
integer y_input;
real dut_in_real, golden_real, dut_out_real, error_percent;
initial begin
   reset = 1'b1;
   clock = 1'b0;
   io_in = 16'h0;
   io_ready = 1'b0;  
   #12;
   reset = 1'b0;
   @(posedge clock);
io_ready = 1'b1;
  for (i=0; i < TEST_SIZE; i = i+1) begin
    io_in = input_theta[i];  
    dut_in_real=ieee754_to_fp(io_in)*180/PI;
    $display("At %dns, the input theta: %h and %f", $time, io_in, dut_in_real);
    @(posedge clock);
  end
  io_ready = 1'b0;
end
integer j =0;
initial begin
  wait (~reset);
  @(posedge clock);
  @(negedge clock);
   while (j  < TEST_SIZE) begin
	@(posedge clock);
	if (io_valid) begin
    golden_real = ieee754_to_fp(output_cos[j]);
    dut_out_real = ieee754_to_fp(io_out);
    
    if (output_cos[j] == 16'h0) begin
      if ((golden_real - dut_out_real <= 0.00001) | (dut_out_real - golden_real <= 0.00001)) begin
        error_percent = 1.0001;
      end else begin
        error_percent = 2;
      end
    end else begin
      error_percent = (dut_out_real - golden_real) / golden_real * 100;
      if (error_percent < 0) begin
        error_percent = -error_percent;
      end
    end

    if (error_percent <= ERROR_TOLERANCE) begin
      $display("At %dns, the test case PASS! error_percent: %f, cos output: %f, expected: %f", $time, error_percent, dut_out_real, golden_real);
    end else begin
      $display("At %dns, the test case FAIL! error_percent: %f, cos output: %f, expected: %f", $time, error_percent, dut_out_real, golden_real);
    end
    j = j+1;
    end
   end
 end
endmodule 
